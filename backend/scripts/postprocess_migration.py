"""
Post-process Alembic migrations to add PostgreSQL enum type creation.

This script is automatically run after 'alembic revision --autogenerate' to
inject enum creation/drop statements for any new enum types.
"""

import re
import sys
from pathlib import Path


def process_migration_file(filepath):
    """Add enum creation/drop code to a migration file."""
    with open(filepath, "r") as f:
        content = f.read()

    # Pattern to find sa.Enum definitions in add_column operations
    enum_pattern = r"op\.add_column\(['\"](\w+)['\"],\s*sa\.Column\(['\"](\w+)['\"],\s*(sa\.Enum\(([^)]+),\s*name=['\"](\w+)['\"]\))"

    matches = list(re.finditer(enum_pattern, content))

    if not matches:
        return False  # No changes needed

    # Extract unique enum types
    enum_types = {}
    for match in matches:
        enum_name = match.group(5)
        enum_def = match.group(3)
        if enum_name not in enum_types:
            enum_types[enum_name] = enum_def

    if not enum_types:
        return False

    # Inject enum creation code at the start of upgrade()
    upgrade_pattern = r'(def upgrade\(\) -> None:.*?""".*?""".*?# ### commands auto generated by Alembic.*?###)'

    def add_enum_creation(match):
        header = match.group(1)
        enum_creation_code = "\n    # Create enum types\n"
        for enum_name, enum_def in enum_types.items():
            var_name = f"{enum_name}_enum"
            enum_creation_code += f"    {var_name} = {enum_def}\n"
            enum_creation_code += (
                f"    {var_name}.create(op.get_bind(), checkfirst=True)\n"
            )
        enum_creation_code += "\n"
        return header + enum_creation_code

    content = re.sub(upgrade_pattern, add_enum_creation, content, flags=re.DOTALL)

    # Update enum references in add_column to use the variable
    for enum_name in enum_types:
        var_name = f"{enum_name}_enum"
        # Replace the inline enum definition with the variable reference
        content = re.sub(
            rf"(op\.add_column\([^,]+,\s*sa\.Column\([^,]+,\s*){re.escape(enum_types[enum_name])}",
            rf"\1{var_name}",
            content,
        )

    # Add enum drop code to downgrade()
    downgrade_pattern = r'(def downgrade\(\) -> None:.*?""".*?""".*?# ### commands auto generated by Alembic.*?###.*?)(# ### end Alembic commands ###)'

    def add_enum_drop(match):
        body = match.group(1)
        footer = match.group(2)
        enum_drop_code = "\n    # Drop enum types\n"
        for enum_name, enum_def in enum_types.items():
            var_name = f"{enum_name}_enum"
            enum_drop_code += f"    {var_name} = {enum_def}\n"
            enum_drop_code += f"    {var_name}.drop(op.get_bind(), checkfirst=True)\n"
        enum_drop_code += "    "
        return body + enum_drop_code + footer

    content = re.sub(downgrade_pattern, add_enum_drop, content, flags=re.DOTALL)

    # Write the modified content
    with open(filepath, "w") as f:
        f.write(content)

    return True


def main():
    """Process the most recently created migration file."""
    # Find the versions directory
    versions_dir = Path(__file__).parent.parent / "alembic" / "versions"

    # Get the most recent migration file
    migration_files = sorted(
        [f for f in versions_dir.glob("*.py") if f.stem != "__init__"],
        key=lambda f: f.stat().st_mtime,
        reverse=True,
    )

    if not migration_files:
        print("No migration files found.")
        return

    latest_migration = migration_files[0]
    print(f"Post-processing migration: {latest_migration.name}")

    if process_migration_file(latest_migration):
        print("✓ Added enum creation/drop statements")
    else:
        print("✓ No enum types detected, no changes needed")


if __name__ == "__main__":
    main()
